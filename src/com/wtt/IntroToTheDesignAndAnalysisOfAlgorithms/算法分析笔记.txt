1. 绪论
2. 算法效率分析基础
3. 蛮力法
4. 减治法
5. 分治法
6. 变治法
7. 时空权衡
8. 动态规划
9. 贪婪技术
10. 迭代改进
11. 算法能力的极限
12. 超越算法能力的极限

chapter 1

设计过程
	理解问题，
	设计算法
	数据结构
	算法描述
	正确性证明
	算法分析
	为算法写代码

重要的问题类型
	排序: 稳定性与是否需要额外空间(在位)
	查找：
	字符串处理： 字符串匹配
	图： 最短路径，填色问题
	组合问题：
	几何问题： 最近对问题，凸包问题
	数值问题：

基本数据结构
	线性数据结构： 数组，链表  栈，队列，优先队列
	图： 无向图，有向图。
		邻接矩阵，邻接链表
		加权图： 权重矩阵或成本矩阵 加权的邻接链表
	树： 即连通无环图  |E| = |V| - 1
		有根树： 顶点v的深度是根到v的简单路径的长度。
			树的高度是根到叶节点的最长简单路径的长度。（有些教材定义为树包含的层数，这样的高度比路径长度大1）
		有序树： 二叉树，二叉查找树，多路查找树
		二叉树： logN <= h <= n-1
		对于任意的有序树，如果每个节点都只包含2个指针，左指针指向该节点的第一个子女，
		而右指针指向该节点的下一个兄弟，此种方法为先子女后兄弟表示法（first child-next sibling representation).
		这样可以将任意一棵有序树转换成一棵二叉树。
	集合： 位向量表示法，以大量存储空间为代价
				线性列表结构来表示
	字典：从集合中查找，新增和删除一个元素，即动态内容的查找。


chpater 2

分析框架：
	输入规模
	运行时间： 由于具体时间受设备影响，应以基本操作执行次数为准（即内循环执行次数）
			T(n) = Cop * C(n)
			如果C(n) = n(n-1) / 2 ~ n^2/2,则依据上述公式在输入规模翻倍时有T(2n)/T(n) ~ 4.
			所以仅关注指数和常数的增长
	最优，最差和平均效率：
		最优：即某种输入可以得到最小的C(n)值，即内循环次数最小
		平均效率：不是简单的求平均数，而是根据不同的输入类型结合概率分布得出结果
		摊销效率： 多次运行，从而避免单次执行的最差效率
渐进符号和基本效率类型：

	O(g(n)): 增长次数小于等于g(n)的函数集合
	Ω(g(n)): 增长次数大于等于g(n)的函数集合
	Θ(g(n)): 增长次数等于g(n)的函数集合
	即O是上界，Ω是下界，对于Θ有对于所有的n>=n0来说，c2g(n)<= t(n) <= c1g(n)

	有用特性： 算法由2个连续的部分组成，其总体性能由性能较差的部分决定

利用极限比较增长次数： lim(n->∞) t(n)/g(n)的值

非递归算法的数学分析：

	1. 决定用哪个(哪些)参数表示输入规模
	2. 找出基本操作（内循环）
	3. 基本操作次数是否只依赖输入规模，若不是，需要对最差，最优，平均效率分别进行研究
	4. 建立基本操作次数的求和表达式
	5. 至少确定该公式的增长次数.

递归算法的数学分析：

	1. 决定用哪个(哪些)参数表示输入规模
	2. 找出基本操作（内循环）
	3. 基本操作次数是否只依赖输入规模，若不是，需要对最差，最优，平均效率分别进行研究
	4. 对于基本操作的执行次数，建立一个递推关系和对应的初始条件
	5. 解递推式或确立其增长次数


chapter 3 蛮力法

基于问题的描述和定义直接解决问题的办法
1. 选择排序，冒泡排序
2. 顺序查找，蛮力字符串匹配
3. 最近对和凸包问题
4. 穷举查找
5. 深度优先查找和广度优先查找
	dfs: 树向边，回边
	bfs: 树向边，交叉边

chapter 4 减治法

原问题和子问题的关系，可以从顶至下（递归）或从底向上（也叫增量法）解决。
1. 减去一个常量（考虑n-1的情况）
2. 减去一个常量因子（大多数应用因子为2）
3. 减去的规模是可变的（计算gcd的欧几里得算法）

1. 插入排序
	从顶向下思考: 对n个数进行排序，假设前面n-1个数已经排好了，
	最后一个数要排序应遍历前面的数列，插入进去从而实现有序，这是递归实现
	但从底向上实现效率更高,n从1开始循环增长到n
2. 拓扑排序
	1. 基于dfs算法的逆后序排列
	2. 基于减治法的逐个删除入度为0的顶点
	上面得到的解不同，所以可以有多个可选解
3. 生成组合对象的算法
	1. 生成排列：
		从底向上生成排列，最小变化算法（minimal change)
		johnson Trotter（对较小的n生成排列）算法
		按字典序排列算法
	2. 生成子集
		所有集合子集的集合称为幂集
		与子集一一对应的位串
		最小变化的生成位串： 二进制反射格雷码（它是循环的，最后一个位串与第一个位串只相差一位）BRGC算法
4. 减常因子算法
	1. 二分查找
	2. 假币问题： 找出一堆硬币中的假币。（将硬币分成3堆要比分成2堆要好）
	3. 俄式乘法： 为计算机通过移位即可完成二进制的折半和加倍提供了基础
	4. 约瑟夫斯问题： （这个故事告诉我们给别人干活时，明白领导的真正意图非常重要）
		每个人从1开始轮流报号，如报1的人杀死号码为2的人，依次进行
		J(2k) = 2J(k) - 1
		J(2k+1) = 2J(k) + 1
		闭合式最佳解： J(6) = J(110|2) = J(101|2) = J(5) 二进制向左循环移位一次

5. 减可变规模算法

	1. 计算中值和选择问题
		寻找中值： lomuto划分 用于划分的2个下标
		快速排序
	2. 插值查找
		对于一个有序的列表，通过线性公式求出待查找值v对应的x下标值，比较A[x]与v的值，比较后再减小规模
		类似于在字典靠前的部分查找单词book
		小规模排序二分查找更快，更大规模插值查找更快
	3. 二叉查找树的查找和插入
		根据树的形状和高度的不同，相同的数据减小的规模无法确定，所以是可变的
	4. 拈游戏
		类似象棋中局面概念一样，每次拿1<=n<=m个棋子，n=0，m+1，...是败局
		从底向上分析，通过数学归纳法可以得到赢或输的模式
		对于多堆的棋子，棋子个数的二进制之和若包含一个1，则当前局面为胜局，
		若和中全部为0时，则当前局面为败局。

chapter 5 分治法

	1. 将一个问题划分成若干子问题，最好子问题规模相同
	2. 对这些子问题求解
	3. 有必要时合并子问题的解
通用分治递推式：
T(n) = aT(b/n) + f(n) f(n)是将结果合并起来所消耗的时间
即原问题可以分成b个子问题，其中a个需要求解。
当a = 1时，即只需要解决一个问题时，即变成减常因子算法

1. 归并排序
2. 快速排序
	Hoare划分： 从左右两端同时扫描再交换的算法
	对于严格递增已经有序的数组，快排的效率是最差的，所以一般在排序前需要打乱数组
3. 二叉树遍历及其相关特性
	前序： 根左右
	中序: 左中右
	后序： 左右根
4. 大整数乘法和Strassen矩阵乘法
	1. 大整数相乘
		相同位数的乘法（不同可以前面补0）,分成2半分治处理。
		即发现两个2位数相乘可以不用4次乘法运算，通过分治3次就可以实现
		即其效率不是普通的n^2,而是n^1.5(log2 3)
		java中的BigInteger
	2. Strassen矩阵乘法
		对于2个2X2的矩阵，普通算法需要8次乘法，4次加法；
		Strassen算法需要7次乘法，18次加减法，当阶数趋近于无穷大时，其效率更高
		对于高阶的矩阵，可以用0补全划分成(n/2) X (n/2)的矩阵
		因为n阶矩阵的乘法得到的结果是n阶的，它的每一个元素都是左边的行元素和右边的列元素相乘得到，
		即n^2个元素中的每个元素都是经过n次乘法得到的，所以一共需要的乘法运算次数是n^2 * n = n^3个。
		Strassen通过递推式M(n)=7M(n)，M(1) = 1可以得出
		M(n) = n ^ 2.87(n ^ log2 7)
		同样通过递推式可以得出Strassen额外需要的加法次数的增长次数与乘法相同
		目前矩阵乘法最快的算法达到了n^2.376,而其理论下界是n^2
5. 用分治法解最近对问题和凸包问题
	1. 最近对问题
		在x坐标轴的中位线上画一条垂线，将点划分成两半进行分治处理
		然后在归并左右两边的最短距离时在一个矩阵内考虑即可。
		这与归并排序算法很相似
	2. 凸包问题
		快包算法： 和快排类似
		相当于一刀切开西瓜，上面一半叫上包，下面一半叫下包，
		在上包中找到距离切开线最远的点，使得三角形pl pMax pr 面积最大
		三角形外的2个半弧形即是所求上包的2部分，继续用三角形重复切分这个过程，知道上包为空，
		再将所有pMax点联合起来即可得到上包的所有极点。
		下包重复这个过程，即可得到整个的凸包。
		（代码实现时，三角形的面积可以用行列式的一半来计算，AB,AC的叉乘/外积是平行四边形的面积，
		三角形是它的一半）

Chapter 6 变治法








