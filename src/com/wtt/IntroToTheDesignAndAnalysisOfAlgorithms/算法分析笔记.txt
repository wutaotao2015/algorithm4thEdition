1. 绪论
2. 算法效率分析基础
3. 蛮力法
4. 减治法
5. 分治法
6. 变治法
7. 时空权衡
8. 动态规划
9. 贪婪技术
10. 迭代改进
11. 算法能力的极限
12. 超越算法能力的极限

chapter 1

设计过程
	理解问题，
	设计算法
	数据结构
	算法描述
	正确性证明
	算法分析
	为算法写代码

重要的问题类型
	排序: 稳定性与是否需要额外空间(在位)
	查找： 
	字符串处理： 字符串匹配
	图： 最短路径，填色问题
	组合问题： 
	几何问题： 最近对问题，凸包问题
	数值问题： 

基本数据结构
	线性数据结构： 数组，链表  栈，队列，优先队列
	图： 无向图，有向图。
		邻接矩阵，邻接链表
		加权图： 权重矩阵或成本矩阵 加权的邻接链表
	树： 即连通无环图  |E| = |V| - 1
		有根树： 顶点v的深度是根到v的简单路径的长度。
			树的高度是根到叶节点的最长简单路径的长度。（有些教材定义为树包含的层数，这样的高度比路径长度大1）
		有序树： 二叉树，二叉查找树，多路查找树
		二叉树： logN <= h <= n-1
		对于任意的有序树，如果每个节点都只包含2个指针，左指针指向该节点的第一个子女，
		而右指针指向该节点的下一个兄弟，此种方法为先子女后兄弟表示法（first child-next sibling representation).
		这样可以将任意一棵有序树转换成一棵二叉树。
	集合： 位向量表示法，以大量存储空间为代价
				线性列表结构来表示
	字典：从集合中查找，新增和删除一个元素，即动态内容的查找。

 
chpater 2

分析框架： 
	输入规模
	运行时间： 由于具体时间受设备影响，应以基本操作执行次数为准（即内循环执行次数）
			T(n) = Cop * C(n)
			如果C(n) = n(n-1) / 2 ~ n^2/2,则依据上述公式在输入规模翻倍时有T(2n)/T(n) ~ 4.
			所以仅关注指数和常数的增长
	最优，最差和平均效率：
		最优：即某种输入可以得到最小的C(n)值，即内循环次数最小
		平均效率：不是简单的求平均数，而是根据不同的输入类型结合概率分布得出结果
		摊销效率： 多次运行，从而避免单次执行的最差效率
渐进符号和基本效率类型：

	O(g(n)): 增长次数小于等于g(n)的函数集合
	Ω(g(n)): 增长次数大于等于g(n)的函数集合
	Θ(g(n)): 增长次数等于g(n)的函数集合
	即O是上界，Ω是下界，对于Θ有对于所有的n>=n0来说，c2g(n)<= t(n) <= c1g(n)

	有用特性： 算法由2个连续的部分组成，其总体性能由性能较差的部分决定

利用极限比较增长次数： lim(n->∞) t(n)/g(n)的值

非递归算法的数学分析：

	1. 决定用哪个(哪些)参数表示输入规模
	2. 找出基本操作（内循环）
	3. 基本操作次数是否只依赖输入规模，若不是，需要对最差，最优，平均效率分别进行研究
	4. 建立基本操作次数的求和表达式
	5. 至少确定该公式的增长次数.

递归算法的数学分析：

	1. 决定用哪个(哪些)参数表示输入规模
	2. 找出基本操作（内循环）
	3. 基本操作次数是否只依赖输入规模，若不是，需要对最差，最优，平均效率分别进行研究
	4. 对于基本操作的执行次数，建立一个递推关系和对应的初始条件
	5. 解递推式或确立其增长次数


chapter 3 蛮力法

基于问题的描述和定义直接解决问题的办法
1. 选择排序，冒泡排序
2. 顺序查找，蛮力字符串匹配
3. 最近对和凸包问题
4. 穷举查找
5. 深度优先查找和广度优先查找
	dfs: 树向边，回边
	bfs: 树向边，交叉边

chapter 4 减治法

原问题和子问题的关系，可以从顶至下（递归）或从底向上（也叫增量法）解决。
1. 减去一个常量
2. 减去一个常量因子（大多数应用因子为2）
3. 减去的规模是可变的（计算gcd的欧几里得算法）

1. 插入排序
	从顶向下思考: 对n个数进行排序，假设前面n-1个数已经排好了，
	最后一个数要排序应遍历前面的数列，插入进去从而实现有序，这是递归实现
	但从底向上实现效率更高
2. 拓扑排序


























